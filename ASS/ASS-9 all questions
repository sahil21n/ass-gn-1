#include <bits/stdc++.h>
using namespace std;


class Graph {
public:
    int V;
    vector<vector<pair<int,int>>> adj;  

    Graph(int V) {
        this->V = V;
        adj.resize(V);
    }

    // Add edge (default is undirected)
    void addEdge(int u, int v, int w = 1, bool undirected = true) {
        adj[u].push_back({v, w});
        if (undirected) adj[v].push_back({u, w});
    }

    
    //                     1. BFS
    
    void BFS(int start) {
        vector<int> vis(V, 0);
        queue<int> q;

        vis[start] = 1;
        q.push(start);

        cout << "\nBFS Traversal: ";

        while (!q.empty()) {
            int node = q.front();
            q.pop();
            cout << node << " ";

            for (auto pr : adj[node]) {
                int neigh = pr.first;
                if (!vis[neigh]) {
                    vis[neigh] = 1;
                    q.push(neigh);
                }
            }
        }
        cout << endl;
    }

    
    //                     2. DFS
   
    void dfsUtil(int node, vector<int>& vis) {
        vis[node] = 1;
        cout << node << " ";

        for (auto pr : adj[node]) {
            int neigh = pr.first;
            if (!vis[neigh]) dfsUtil(neigh, vis);
        }
    }

    void DFS(int start) {
        vector<int> vis(V, 0);
        cout << "\nDFS Traversal: ";
        dfsUtil(start, vis);
        cout << endl;
    }

    
    //              3. MINIMUM SPANNING TREE – KRUSKAL
   
    int findParent(int node, vector<int>& parent) {
        if (parent[node] == node) return node;
        return parent[node] = findParent(parent[node], parent);
    }

    void unionSet(int u, int v, vector<int>& parent, vector<int>& rank) {
        u = findParent(u, parent);
        v = findParent(v, parent);

        if (rank[u] < rank[v]) parent[u] = v;
        else if (rank[v] < rank[u]) parent[v] = u;
        else {
            parent[v] = u;
            rank[u]++;
        }
    }

    void Kruskal() {
        vector<pair<int, pair<int,int>>> edges;

        // Convert adjacency list → edge list
        for (int u = 0; u < V; u++) {
            for (auto pr : adj[u]) {
                int v = pr.first, w = pr.second;
                if (u < v) edges.push_back({w, {u, v}});
            }
        }

        sort(edges.begin(), edges.end());

        vector<int> parent(V), rank(V, 0);
        for (int i = 0; i < V; i++) parent[i] = i;

        int mst_cost = 0;

        cout << "\nKruskal MST Edges:\n";

        for (auto e : edges) {
            int w = e.first;
            int u = e.second.first;
            int v = e.second.second;

            int pu = findParent(u, parent);
            int pv = findParent(v, parent);

            if (pu != pv) {
                cout << u << " -- " << v << " (" << w << ")\n";
                mst_cost += w;
                unionSet(u, v, parent, rank);
            }
        }

        cout << "Total MST Cost = " << mst_cost << endl;
    }

    
    //              4. MINIMUM SPANNING TREE – PRIM
    
    void Prim(int start = 0) {
        vector<int> key(V, INT_MAX);
        vector<int> parent(V, -1);
        vector<bool> inMST(V, false);

        key[start] = 0;

        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
        pq.push({0, start});

        while (!pq.empty()) {
            int u = pq.top().second;
            pq.pop();

            if (inMST[u]) continue;
            inMST[u] = true;

            for (auto pr : adj[u]) {
                int v = pr.first, w = pr.second;

                if (!inMST[v] && w < key[v]) {
                    key[v] = w;
                    parent[v] = u;
                    pq.push({key[v], v});
                }
            }
        }

        cout << "\nPrim MST Edges:\n";
        int cost = 0;

        for (int v = 1; v < V; v++) {
            cout << parent[v] << " -- " << v << " (" << key[v] << ")\n";
            cost += key[v];
        }

        cout << "Total MST Cost = " << cost << endl;
    }

    
    //              5. DIJKSTRA SHORTEST PATH
 
    void Dijkstra(int src) {
        vector<int> dist(V, INT_MAX);
        dist[src] = 0;

        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
        pq.push({0, src});

        while (!pq.empty()) {
            int d = pq.top().first;
            int u = pq.top().second;
            pq.pop();

            for (auto pr : adj[u]) {
                int v = pr.first, w = pr.second;

                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    pq.push({dist[v], v});
                }
            }
        }

        cout << "\nDijkstra Shortest Distances from " << src << ":\n";
        for (int i = 0; i < V; i++) {
            cout << src << " → " << i << " = " << dist[i] << endl;
        }
    }
};


int main() {
    int V = 6;
    Graph g(V);

    // Creating sample graph
    g.addEdge(0, 1, 4);
    g.addEdge(0, 2, 2);
    g.addEdge(1, 2, 1);
    g.addEdge(1, 3, 5);
    g.addEdge(2, 3, 8);
    g.addEdge(3, 4, 6);
    g.addEdge(4, 5, 3);

    cout << "\n===== GRAPH ALGORITHMS (UCS301 - Assignment 9) =====\n";

    g.BFS(0);
    g.DFS(0);
    g.Kruskal();
    g.Prim(0);
    g.Dijkstra(0);

    return 0;
}

